# -*- coding: utf-8 -*-
"""preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sIN17DNamjtelwj-YHK7vzF9ONsTw_6y
"""

from google.colab import drive

import torch

device = 'cuda' if torch.cuda.is_available() else 'cpu'

drive.mount('drive')

from pathlib import Path

dir_path = Path('/content/drive/MyDrive/cropped')

dir_path

image_list = list(dir_path.glob('*/*.jpg'))

image_list[:5]

from PIL import Image
import random

img = Image.open(random.choice(image_list))
img.width,img.height

img

import numpy as np
from matplotlib import pyplot as plt

img = np.array(img)
img

plt.imshow(img),img.shape

def plot_img(image_list:list):
    img = Image.open(random.choice(image_list))
    print(f"height: {img.height}\nwidth :{img.width}")
    img = np.array(img)
    plt.imshow(img)
    plt.show()

plot_img(image_list)

import torch
import torchvision
import torchvision.transforms as transforms

train_transforms = transforms.Compose([
    transforms.Resize(size=(64,64)),
    transforms.RandomHorizontalFlip(0.2),
    transforms.RandomVerticalFlip(0.2),
    transforms.RandomRotation(15),  # Rotate images by up to 15 degrees
    transforms.ToTensor(),
    #transforms.Normalize(mean=[0.485, 0.456, 0.406],  # Mean values for each channel
                         #std=[0.229, 0.224, 0.225])
])
test_transforms = transforms.Compose([
    transforms.Resize(size=(64,64)),
    transforms.ToTensor()
])

train_dir = dir_path / 'train'
test_dir = dir_path / 'test'

def plot_transforms(image_list:list):
    img = Image.open(random.choice(image_list))
    transformed = train_transforms(img).permute(1,2,0)
    plt.imshow(transformed)

plot_transforms(image_list)

def plot_difference(image_list=image_list,transform=train_transforms):
    img = Image.open(random.choice(image_list))
    fig,ax = plt.subplots(1,2)
    ax[0].imshow(img)
    ax[0].set_title(f'original')
    transformed = transform(img)
    ax[1].imshow(transformed.permute(1,2,0))
    ax[1].set_title(f'transformed')

num = 5

for i in range(num):
    plot_difference()

import torch.nn as nn
from torchvision import datasets
from torch.utils.data import Dataset

class DOGDATASET(Dataset):
  def __init__(self,dir_path,transform=None):
    super().__init__()
    self.path = list(Path(dir_path).glob('*.jpg'))
    self.transform = transform

  def __len__(self):
    return len(self.path)

  def load_image(self,index):
    self.img = self.path[index]
    return Image.open(self.img)

  def __getitem__(self,index):
    image = self.load_image(index)
    if self.transform:
      return self.transform(image)
    else:
      return image

train_data = DOGDATASET(dir_path=train_dir,transform=train_transforms)
test_data = DOGDATASET(dir_path=test_dir,transform=test_transforms)

train_data,test_data

from torch.utils.data import DataLoader

bs = 4

train_loader = DataLoader(dataset=train_data,batch_size=bs,shuffle=True)
test_loader = DataLoader(dataset=test_data,batch_size=bs,shuffle=False)

train_loader,test_loader

sample = next(iter(train_data))
sample.shape

len(train_loader),len(test_loader)

class Encoder(nn.Module):
  def __init__(self,latent_dim):
    super().__init__()

    self.conv1 = nn.Conv2d(
        in_channels=3,
        out_channels=32,
        kernel_size=4,
        stride=1,
    )
    self.conv2 = nn.Conv2d(
        in_channels=32,
        out_channels=64,
        kernel_size=4,
        stride=1,
    )
    self.relu = nn.ReLU()
    self.fc_mu = nn.Linear(215296,latent_dim)
    self.fc_logvar = nn.Linear(215296,latent_dim)
  def forward(self,x):
    x = self.conv1(x)
    x = self.relu(x)
    x = self.conv2(x)
    x = self.relu(x)
    x = x.view(x.size(0),-1)
    mu = self.fc_mu(x)
    logvar = self.fc_logvar(x)
    return mu,logvar

z_dim = 200

encoder = Encoder(latent_dim=z_dim).to(device)

sample = torch.randn(8,3,64,64)

mu,logvar = encoder(sample.to(device))
len(mu),len(logvar)

!pip install torchinfo

from torchinfo import summary

sample.shape

summary(model=encoder,input_size=[8,3,64,64])

class Decoder(nn.Module):
  def __init__(self,latent_dim):
    super().__init__()
    self.fc = nn.Linear(latent_dim,215296)
    self.deconv1 = nn.ConvTranspose2d(
        in_channels=64,
        out_channels=32,
        kernel_size=4,
        stride=1
    )
    self.deconv2 = nn.ConvTranspose2d(
        in_channels=32,
        out_channels=3,
        kernel_size=4,
        stride=1
    )
    self.deconv3 = nn.ConvTranspose2d(
        in_channels=32,
        out_channels=3,
        kernel_size=4,
        stride=1
    )
    self.relu = nn.ReLU()
  def forward(self,z):
    x = self.fc(z)
    x = x.view(x.size(0),64,58,58)
    x = self.relu(x)
    x = self.deconv1(x)
    x = self.relu(x)
    x = torch.sigmoid(self.deconv2(x))
    return x

decoder = Decoder(z_dim).to(device)

d_sample = torch.randn(8,z_dim)

output = decoder(d_sample.to(device))

summary(model=decoder,input_size=[8,200])

class VAE(nn.Module):
  def __init__(self,latent_dim):
    super().__init__()
    self.encoder = Encoder(latent_dim).to(device)
    self.decoder = Decoder(latent_dim).to(device)

  def reparameterize(self,mu,logvar):
    eps = torch.randn_like(logvar)
    z = mu + eps * torch.exp(0.5 * logvar)
    return z
  def forward(self,x):
    mu,logvar = self.encoder(x)
    z = self.reparameterize(mu,logvar)
    x_hat = self.decoder(z)
    return x_hat,mu,logvar

model = VAE(z_dim).to(device)

a,b,c= model(sample.to(device))

summary(model=model,input_size=[8,3,64,64])

model.state_dict()

sample_data = torch.randn(1,3,64,64)

model.eval()
with torch.no_grad():
  a,b,c = model(sample_data.to(device))

a.shape

images = next(iter(train_loader))

a,b,c = model(images.to(device))

def loss_fn(recon_x,x,mu,logvar):
  reconstruction_loss = nn.MSELoss(reduction='sum')(recon_x,x)
  #print(reconstruction_loss)
  kl_divergence = 0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
  #print(kl_divergence)
  return reconstruction_loss * 10000 + kl_divergence

loss_fn(images.to(device),a.to(device),b.to(device),c.to(device))

optimizer = torch.optim.Adam(model.parameters(),lr=0.0002)

def train_step(model=model,
               dataloader=train_loader,
               lossfn=loss_fn,
               optimizer=optimizer,
               device=device):
  model.train()
  train_loss = 0
  for X in dataloader:
    X = X.to(device)
    optimizer.zero_grad()
    recon_x,mu,logvar = model(X)
    loss = loss_fn(recon_x,X,mu,logvar)
    train_loss = train_loss + loss
    loss.backward()
    optimizer.step()
  train_loss /= len(dataloader)
  return train_loss

def test_step(model=model,
              dataloader=test_loader,
              loss_fn=loss_fn,
              device=device):
  model.eval()
  test_loss = 0
  for X in dataloader:
    X = X.to(device)
    recon_x,mu,logvar = model(X)
    loss = loss_fn(recon_x,X,mu,logvar)
    test_loss += loss
  test_loss /= len(dataloader)
  return test_loss

epochs = 50

for epoch in range(epochs):
  train_loss = train_step()
  test_loss = test_step()
  print(f"epoch: {epoch} | train loss: {train_loss} | test loss: {test_loss}")
  if test_loss < 3000000:
    break

model.eval()
x = train_data[3]
x = x.unsqueeze(dim=0)
with torch.no_grad():
  z,a,b = model(x.to(device))

fig,ax = plt.subplots(1,2)
ax[0].imshow(x.squeeze().permute(1,2,0))
ax[1].imshow(z.squeeze().permute(1,2,0).cpu())

def plot_output(train_data):
  model.eval()
  x = random.choice(train_data)
  x = x.unsqueeze(dim=0)
  with torch.no_grad():
    z,a,b = model(x.to(device))
  fig,ax = plt.subplots(1,2)
  ax[0].imshow(x.squeeze().permute(1,2,0))
  ax[1].imshow(z.squeeze().permute(1,2,0).cpu())

for i in range(5):
  plot_output(train_data)

for i in range(5):
  plot_output(test_data)

img = Image.open('/content/GettyImages-1170243723.jpg')
img = test_transforms(img)
img

model.eval()
with torch.no_grad():
  result,a,b = model(img.unsqueeze(dim=0).to(device))

img.shape

fig,ax = plt.subplots(1,2)
ax[0].imshow(img.squeeze().permute(1,2,0))
ax[1].imshow(result.squeeze().permute(1,2,0).cpu())